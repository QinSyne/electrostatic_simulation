# 电场数值模拟项目展示报告

PB24081571 刘沁昕

## 1. 项目背景与简介

在物理学中，静电场是看不见摸不着的，但它却主宰着电荷的运动。对于规则的几何形状（如无限大平板、球体），我们可以用数学公式精确计算出电场分布。然而，在现实世界中，电极的形状往往千奇百怪（如尖端、不规则导线等等），这时候传统的解析数学方法就无能为力了。

但是我们通过电磁学的学习我们知道，有一个强大的定理是唯一性定理，即我们给定初始的边界电势条件和内部电荷分布，我们就可以唯一确定关心区域的电场、电势的分布

本人作为一名计算机专业的学生，自然联想到使用计算机强大的计算能力。因此本项目采用计算机数值模拟的方法，将连续的物理空间“网格化”，通过计算机强大的迭代计算能力，求解出二维空间中任意形状电极周围的电势与电场分布。这不仅是一个物理仿真工具，更是一个展示计算机科学如何解决科学问题的初步尝试案例，希望为读者带来一些启发

---

## 2. 物理原理：

### 2.1 核心方程：

静电场的核心规律由高斯定理决定。在没有自由电荷的真空中，电势 $V$ 满足拉普拉斯方程 ：

$$ \nabla^2 V = \frac{\partial^2 V}{\partial x^2} + \frac{\partial^2 V}{\partial y^2}+ \frac{\partial^2 V}{\partial z^2} = 0 $$

这个方程的物理含义非常直观：空间中任意一点的电势，倾向于等于它周围所有点电势的平均值。 只有这样，电势分布才是“平滑”的，能量才是最低的。

### 2.2 离散化：把空间变成棋盘（可以认为我们不关心z方向，在z上处处相等）

计算机无法处理无限精细的连续空间，所以我们将空间划分成 $N \times N$ 的网格（就像一个围棋棋盘）。

利用数学上的**有限差分法 **，我们可以把上面的微分方程转化为一个简单的代数公式。对于网格上的任意一点 $(i, j)$，它的电势 $V_{i,j}$ 必须满足：

$$ V_{i,j} = \frac{1}{4} (V_{i+1,j} + V_{i-1,j} + V_{i,j+1} + V_{i,j-1}) $$

也就是中间格子的电压 = (上 + 下 + 左 + 右) / 4。

下面是详细推导：

#### 拉普拉斯方程的有限差分法离散化推导（二维静电场）

##### 前提假设

1. 模拟区域为无电荷区域（$\rho = 0$），静电势满足拉普拉斯方程：  
   $$\nabla^2 V = 0$$
2. 将连续空间离散为 $N_x \times N_y$ 均匀网格，网格单元边长（步长）为 $\Delta x = \Delta y = h$（简化计算，取等步长）；
3. 网格点坐标定义：第 $i$ 行（y方向）、第 $j$ 列（x方向）的网格点坐标为 $(x_j, y_i) = (j \cdot h, i \cdot h)$；
4. 网格点电势表示：该点的静电势记为 $V(i,j) = V(x_j, y_i)$。

---

#### 第一步：拉普拉斯方程的二维展开

二维空间中，拉普拉斯算子 $\nabla^2$（直角坐标系）定义为：  
$$\nabla^2 V = \frac{\partial^2 V}{\partial x^2} + \frac{\partial^2 V}{\partial y^2}$$
无电荷区域满足拉普拉斯方程，因此：  
$$\frac{\partial^2 V}{\partial x^2} + \frac{\partial^2 V}{\partial y^2} = 0 \tag{1}$$

---

#### 第二步：二阶偏导数的有限差分近似

有限差分法的核心是用**相邻网格点的电势差值**近似替代**连续的二阶偏导数**。以下分别推导 $\frac{\partial^2 V}{\partial x^2}$ 和 $\frac{\partial^2 V}{\partial y^2}$ 的离散形式。

##### 2.1 对 $x$ 方向二阶偏导数 $\frac{\partial^2 V}{\partial x^2}$ 的离散

对固定的 $y = y_i$（即固定第 $i$ 行），电势 $V$ 仅随 $x$ 变化，记为 $V(x) = V(x, y_i)$。  
根据**泰勒级数展开**，将 $V(x + h)$ 和 $V(x - h)$ 在 $x = x_j$ 处展开（保留到 $h^2$ 项）：  

- 右侧相邻点（$x = x_j + h = x_{j+1}$）：  
  $$V(x_{j+1}, y_i) = V(x_j, y_i) + h \cdot \frac{\partial V}{\partial x}\bigg|_{(x_j,y_i)} + \frac{h^2}{2} \cdot \frac{\partial^2 V}{\partial x^2}\bigg|_{(x_j,y_i)} + O(h^3) \tag{2}$$
- 左侧相邻点（$x = x_j - h = x_{j-1}$）：  
  $$V(x_{j-1}, y_i) = V(x_j, y_i) - h \cdot \frac{\partial V}{\partial x}\bigg|_{(x_j,y_i)} + \frac{h^2}{2} \cdot \frac{\partial^2 V}{\partial x^2}\bigg|_{(x_j,y_i)} + O(h^3) \tag{3}$$

将两式**相加**，消去一阶导数项 $\frac{\partial V}{\partial x}$：  
$$V(x_{j+1}, y_i) + V(x_{j-1}, y_i) = 2V(x_j, y_i) + h^2 \cdot \frac{\partial^2 V}{\partial x^2}\bigg|_{(x_j,y_i)} + 2O(h^3)$$

忽略高阶小项 $O(h^3)$（网格步长 $h$ 足够小时可近似），整理得 $x$ 方向二阶偏导数的离散形式：  
$$\frac{\partial^2 V}{\partial x^2}\bigg|_{(x_j,y_i)} \approx \frac{V(x_{j+1}, y_i) - 2V(x_j, y_i) + V(x_{j-1}, y_i)}{h^2} \tag{4}$$
用网格点简写表示为：  
$$\frac{\partial^2 V}{\partial x^2}\bigg|_{(i,j)} \approx \frac{V(i,j+1) - 2V(i,j) + V(i,j-1)}{h^2} \tag{4'}$$

##### 2.2 对 $y$ 方向二阶偏导数 $\frac{\partial^2 V}{\partial y^2}$ 的离散
同理，对固定的 $x = x_j$（即固定第 $j$ 列），电势 $V$ 仅随 $y$ 变化，记为 $V(y) = V(x_j, y)$。  
将 $V(y + h)$ 和 $V(y - h)$ 在 $y = y_i$ 处泰勒展开（保留到 $h^2$ 项），相加后消去一阶导数项，最终可得：  
$$\frac{\partial^2 V}{\partial y^2}\bigg|_{(i,j)} \approx \frac{V(i+1,j) - 2V(i,j) + V(i-1,j)}{h^2} \tag{5}$$

---

#### 第三步：代入拉普拉斯方程，得到离散化公式
 代入原始拉普拉斯方程 ：  
$$\frac{V(i,j+1) - 2V(i,j) + V(i,j-1)}{h^2} + \frac{V(i+1,j) - 2V(i,j) + V(i-1,j)}{h^2} = 0$$

由于 $h \neq 0$，两边同乘 $h^2$ 消去分母：  
$$V(i,j+1) - 2V(i,j) + V(i,j-1) + V(i+1,j) - 2V(i,j) + V(i-1,j) = 0$$

最终解出网格点 $(i,j)$ 的电势 $V(i,j)$：  
$$\boxed{V(i,j) = \frac{1}{4}\left[ V(i+1,j) + V(i-1,j) + V(i,j+1) + V(i,j-1) \right]}$$



---

## 3. 算法原理：计算机是如何“猜”出答案的？

我们的任务是：已知边界上的电压，求中间所有未知格子的电压。
这是一个巨大的联立方程组（如果有 $60 \times 60$ 个格子，就有 3600 个未知数）。直接求解太慢，我们采用**迭代法**，也就是“不断修正猜测”的方法。

### 3.1 基础算法：Jacobi 迭代法

这是最直观的方法。
1.  **初始猜测**：假设中间所有格子都是 0V。
2.  **迭代更新**：对每一个格子，算出它周围四个邻居的平均值，作为它下一轮的新值。
3.  **重复**：一遍又一遍地做，直到所有格子的数值不再变化（收敛）。

**伪代码**：
```python
while (误差 > 允许范围):
    for 每个点 (i, j):
        # 算出邻居的平均值
        average = (V[i+1,j] + V[i-1,j] + V[i,j+1] + V[i,j-1]) / 4
        # 更新当前点
        V_new[i,j] = average
    V = V_new
```
*缺点*：信息从边界传到中心需要很多轮，收敛速度很慢。

### 3.2 进阶算法：SOR (超松弛迭代法)

SOR (Successive Over-Relaxation) 是对基础算法的聪明改进。
它的核心思想是：**预测趋势，步子迈大点**。

我们引入一个**松弛因子 $\omega$** (通常取 1.8 左右)：
$$ V_{new} = V_{old} + \omega \times (V_{average} - V_{old}) $$

**伪代码**：

```python
while (误差 > 允许范围):
    for 每个点 (i, j):
        average = 邻居平均值
        # 修正量 = 目标值 - 当前值
        correction = average - V[i,j]
        # 超额修正！
        V[i,j] = V[i,j] + omega * correction
```
*效果*：收敛速度通常比 Jacobi 快 10 倍以上

### 3.3 核心代码实现解析 (Solver.py)

`solver.py` 是整个项目的核心引擎，它虽然代码量不大，但包含了非常多的**计算机科学与物理学结合的智慧**。

#### 3.3.1 数据结构设计：

在 `__init__` 函数中，我们定义了两个核心矩阵：

```python
self.V = np.zeros((self.ny, self.nx))
self.boundary_mask = np.zeros((self.ny, self.nx), dtype=bool)
```

*   **`self.V` (电势场)**：这是一个二维浮点数数组。它直接对应物理空间中的电势分布。
*   **`self.boundary_mask` (边界掩码)**：这是一个二维布尔数组。
    *   **精妙之处**：它将“物理属性”（电压值）和“几何属性”（是否固定）解耦了。
    *   在迭代过程中，我们不需要每次都去判断“这个点是不是金属板？”，只需要在最后用这个掩码统一恢复一次边界值即可。这极大地简化了算法逻辑。

#### 3.3.2 边界处理技巧：向量化几何计算

注意到 `set_boundary_line` 和 `set_boundary_circle` 中并没有使用 `for` 循环来遍历所有点，而是使用了 `np.ogrid`。

```python
# 创建网格坐标矩阵
Y, X = np.ogrid[:self.ny, :self.nx]
```

*   **向量化**：这是 NumPy 的核心魔法。`X` 和 `Y` 不是普通的数字，而是代表整个坐标系的矩阵。
*   **距离场计算**：
    
    ```python
    dist_sq = (X - cx)**2 + (Y - cy)**2
    mask = dist_sq <= radius**2
    ```
    这两行代码，实际上是在**一瞬间**计算了网格上所有 3600 个点到圆心的距离，并判断它们是否在圆内。
*   **优势**：如果用 Python 的 `for` 循环去写这个逻辑，速度会慢 100 倍以上。这种写法让我们可以轻松处理任意复杂的几何形状（只要能写出数学解析式）。

#### 3.3.3 核心算法优化：棋盘格更新 (Red-Black Ordering)

这是整个脚本中优化部分，位于 `_update_checkerboard` 函数。

**问题背景**：
SOR 算法要求我们在计算当前点时，必须使用**邻居的最新值**。

*   在串行代码（C/C++ 的 `for` 循环）中，这很容易实现。
*   但在 Python/NumPy 中，为了快，我们必须**并行计算**（一次算整个矩阵）。并行计算时，所有点同时更新，谁也看不到谁的“最新值”。

**解决方案：棋盘格染色**
我们将网格像国际象棋棋盘一样分成**红**、**黑**两组。

1.  **红格子 (offset=0)** 的邻居全是黑格子。
2.  **黑格子 (offset=1)** 的邻居全是红格子。

**精妙的操作流程**：
1.  **先更新所有红格子**：此时它们读取的是黑格子的旧值（没问题，因为黑格子还没动）。
2.  **再更新所有黑格子**：此时它们读取的是红格子的**新值**（因为红格子刚才已经更新过了）。

```python
# 1. 更新“红”格子
self._update_checkerboard(0, omega)
# 2. 更新“黑”格子
self._update_checkerboard(1, omega)
```

通过这种**分批次并行**的策略，我们既享受了 NumPy 向量化带来的百倍加速，又完美保留了 SOR 算法“利用最新信息加速收敛”的数学特性。

---

## 4. 项目效果展示

本项目实现了以下功能并生成了可视化图表（详见 `res/` 文件夹）：

### 4.1 模拟场景

成功模拟了多种经典物理场景：
1.  **平行板电容器**：验证了匀强电场和边缘效应。
2.  **倾斜板电容器**：展示了非规则边界下的电场扭曲。
3.  **尖端放电**：模拟了避雷针原理，展示了尖端处极高的电场密度。
4.  **同轴电缆/圆形导体**：处理了曲线边界条件。

### 4.2 可视化
生成了包含以下信息的综合图表：
* **电势热力图 (Heatmap)**：用颜色深浅直观展示电压高低。
* **电场流线图 (Streamlines)**：展示电荷受力方向，清晰可见电场线从正极出发终止于负极。
*   **算法性能对比**：
    * **收敛曲线**：展示了误差随时间下降的趋势（SOR 呈断崖式下降）。
    * **柱状图**：直观对比迭代次数（例如 Jacobi 需 2000 次，SOR 仅需 150 次）。

---

## 5. 项目前景与展望

虽然目前是一个二维的静态模拟，但这个框架具有很多的扩展空间：

1.  **三维模拟 (3D)**：
    *   原理完全相同，只是从 4 个邻居变成 6 个邻居（上下左右前后）。可以模拟更真实的物理设备。
2.  **时变电磁场 (FDTD)**：
    *   引入时间变量，模拟电磁波的传播（如 Wi-Fi 信号在房间内的覆盖）。
3.  **交互式设计工具**：
    *   开发一个 GUI 界面，用户可以用鼠标随意画电极，实时看到电场分布的变化。
4.  **结合人工智能 (AI)**：
    *   利用 **PINNs (物理信息神经网络)**，让神经网络去学习拉普拉斯方程。对于超复杂几何结构，AI 的求解速度可能比传统迭代法更快。

---

**总结**：本项目以计算机科学的视角重构了物理学经典问题，通过算法优化实现了高效求解，是 CS 与 Physics 交叉学科的一次成功实践。
