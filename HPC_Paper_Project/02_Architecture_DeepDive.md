# 第二课：计算机体系结构初探 (Architecture Deep Dive)

你的直觉非常敏锐！`diff = np.abs(self.V - V_old).max()` 确实是一个潜在的性能瓶颈。

在并行计算中，这被称为 **Reduction (归约)** 操作。
虽然我们可以让 100 个 CPU 核心分别计算各自负责区域的“局部最大值”（这是并行的），但最后必须有一个“组长”把这 100 个局部最大值收集起来，比较出一个“全局最大值”。这个收集和比较的过程，往往需要**同步 (Synchronization)**，即所有人都得停下来等最慢的那个人做完，然后才能进入下一轮迭代。

理解了这一点，我们就可以深入硬件底层，看看是什么在支撑我们的计算。

---

## 1. CPU：全能的“教授”

你现在的代码运行在 CPU 上。CPU (Central Processing Unit) 就像一位**博学的教授**。

### 特点
- **核心少而强**：现代 CPU 通常只有 4-64 个核心。每个核心都非常复杂，擅长处理复杂的逻辑判断（if-else）、分支预测和乱序执行。
- **低延迟 (Low Latency)**：CPU 的设计目标是让单个任务尽可能快地完成。

### 关键概念：SIMD (单指令多数据流)
这是 CPU 做科学计算的秘密武器。
想象一下，你要计算两个数组相加：`C = A + B`。

- **标量模式 (Scalar)**：
    1. 取 A[0], B[0] -> 加法 -> 存 C[0]
    2. 取 A[1], B[1] -> 加法 -> 存 C[1]
    ... (重复 N 次)
- **SIMD 模式 (Vector)**：
    1. 一次性搬运 A[0:4] 和 B[0:4] 到专用寄存器。
    2. **一条指令**同时做 4 个加法。
    3. 一次性存回 C[0:4]。

**你的 `solver.py` 中使用了 NumPy。NumPy 的底层正是利用了 CPU 的 SIMD 指令集 (如 AVX2, AVX-512) 来加速数组运算的。这就是为什么它比纯 Python 循环快得多的原因。**

---

## 2. GPU：暴力的“学生军团”

GPU (Graphics Processing Unit) 最初是为了玩游戏（渲染图形）设计的，但现在它是科学计算的霸主。GPU 就像**成千上万个小学生**。

### 特点
- **核心多而简**：一个 GPU 可能有 5000+ 个核心！但每个核心都很简单，不擅长复杂的逻辑判断。
- **高吞吐量 (High Throughput)**：GPU 不在乎单个任务做多快，它在乎的是**同一时间能做多少个任务**。

### 为什么 GPU 适合你的电磁学模拟？

你的 `solver.py` 是典型的 **SIMT (Single Instruction Multiple Threads)** 场景：
- **Single Instruction**: 大家都执行相同的公式 `V_new = 0.25 * (上+下+左+右)`。
- **Multiple Threads**: 每个网格点 $(i, j)$ 都是一个独立的线程。

如果把你的代码移植到 GPU 上，你可以让 10,000 个核心同时计算 10,000 个网格点，瞬间完成一次迭代。

---

## 3. 内存墙 (The Memory Wall)：真正的瓶颈

在高性能计算中，最大的敌人往往不是计算速度，而是**数据搬运速度**。

### 厨房比喻

- **CPU/GPU 核心** = **厨师** (切菜速度极快)
- **内存 (RAM)** = **超市** (存放食材)
- **缓存 (Cache)** = **案板旁边的备菜碗** (容量小，但伸手就能以此拿到)

**问题**：
如果厨师切菜只需 1 秒，但去超市买菜来回需要 100 秒，那么厨师切得再快也没用。这就是“内存墙”。

### 对你的项目的启示

在 `solver.py` 中：
```python
V_neighbors = 0.25 * (V_old[1:-1, 0:-2] + V_old[1:-1, 2:] + ...)
```
这一行代码涉及大量的**内存读取**。
- `V_old` 是一个巨大的矩阵，存放在内存(RAM)中。
- CPU 需要不断地把数据从 RAM 搬运到 Cache，再搬运到寄存器进行计算。
- 如果网格太大，Cache 装不下，CPU 就必须频繁访问慢速的 RAM，导致性能急剧下降。

这被称为 **Memory Bound (内存受限)** 问题。优化这种程序的关键，往往是**想办法复用数据，减少去“超市”的次数**。

---

## 4. 课后思考

假设你的电脑 CPU 有 8 个核心。
你现在的 `solver.py` 是用 NumPy 写的。
当你运行 `python solver.py` 时，你觉得它是在用 **1 个核心** 跑，还是 **8 个核心** 同时跑？

(提示：这取决于 NumPy 的底层配置，通常涉及 BLAS 库。你可以打开任务管理器/活动监视器，运行你的程序，观察 CPU 占用率来验证你的猜想。)
